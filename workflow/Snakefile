import re
import sys
import csv
import os
import glob
import pandas as pd
import numpy as np
from snakemake.utils import validate

# working directory
workdir: "."
workdir_path = "."


# config file name
configfile: "config/config.yaml"


include: "rules/common.smk"
include: "Snakefile_microscopy"
include: "Snakefile_IMC"
include: "Snakefile_IMS"
include: "Snakefile_QC"
include: "Snakefile_overlap"



### Start of workflow.
sample_metadata_df = read_sample_metadata(config["sample_metadata"])
validate(sample_metadata_df, "sample_metadata.schema.yaml")

project_names = sample_metadata_df["project_name"].tolist()
sample_names = sample_metadata_df["sample_name"].tolist()

# check if directory structure exists
for project in project_names:
    if not os.path.isdir(os.path.join(workdir_path, "results", project)):
        tmpdir = os.path.join(workdir_path, "results", project)
        sys.exit(
            f"Project directory {tmpdir} does not exist! Create them with 'bash workflow/scripts/setup_project_results_directory.sh -p PROJECT_NAME'"
        )

unique_project_names = list(set(project_names))

preIMS_location_files_complete = []
for pr in unique_project_names:
    preIMS_location_files = os.listdir(f"results/{pr}/data/preIMS_location")
    preIMS_location_files = [
        re.findall(f"{pr}_reg_mask_on_preIMS_*.geojson", s)
        for s in preIMS_location_files
    ]
    preIMS_location_files = [
        f"results/{pr}/data/preIMS_location/{s[0]}" for s in preIMS_location_files if s
    ]
    preIMS_location_files_complete += preIMS_location_files


# print("unique project_names:")
# print(unique_project_names)

imzml_filenames = sample_metadata_df["imzml_filename"].tolist()
imzml_project = [
    f"{imzml_filenames[i]}:{project_names[i]}" for i in range(len(imzml_filenames))
]
unique_imzml_project = list(set(imzml_project))
unique_imzml_project = [ip.split(":") for ip in unique_imzml_project]
unique_imzml_project = [
    [e[0] for e in unique_imzml_project],
    [e[1] for e in unique_imzml_project],
]
unique_imzml_project[0] = [os.path.splitext(e)[0] for e in unique_imzml_project[0]]

stages = config["stages"]

def return_output_files(wildcards):
    files = []
    if "IMS" in stages or "all" in stages:
        files +=  expand(
            "results/{project_name}/data/IMS/{imzml_base}_peaks.h5",
            zip,
            project_name=unique_imzml_project[1],
            imzml_base=unique_imzml_project[0],
        )
    if "regIMS" in stages or "all" in stages:
        files += [choose_imsml_coordsfile_base(sample_names[i], project_names[i]) for i in range(len(sample_names))]

    if "regIMC" in stages or "all" in stages:
        core_names = [
            get_column_entry_from_metadata_two_conditions(
                sample_names[i],
                project_names[i],
                'core_name',
                'sample_name',
                'project_name',
                read_sample_metadata(config['sample_metadata']))
            for i in range(len(sample_names))
        ]
        files += expand(
            "results/{project_name}/data/IMC_location/{project_name}_registered_IMC_mask_on_postIMC_{core}.geojson",
            zip,
            project_name=project_names,
            core=core_names,
        )
    if "Microscopy" in stages or "all" in stages:
        files += expand(
            "results/{project_name}/data/postIMC/{sample}_transformed_on_postIMS.ome.tiff",
            zip,
            project_name=project_names,
            sample=sample_names,
        )
    if "overlap" in stages or "all" in stages:
        files += expand(
            "results/{project_name}/data/cell_overlap/{project_name}_{imzml_base}_peak_cell_overlap.csv",
            zip,
            project_name=unique_imzml_project[1],
            imzml_base=unique_imzml_project[0],
        )
    if "QC" in stages or "all" in stages:
        files += expand(
            "results/{project_name}/data/registration_metric/report/{project_name}_registration_evaluation.html",
            project_name=project_names,
        )
        files += expand(
            "results/{project_name}/data/IMS/{project_name}_{sample}_IMS_transformed.ome.tiff",
            zip,
            project_name=project_names,
            sample=sample_names,
        )
    return files


rule all:
    input:
        return_output_files,


rule transform_postIMC_to_postIMS:
    threads: 32
    resources:
        mem_mb=100000,
    params:
        input_spacing=lambda wildcards: get_column_entry_from_metadata(
            wildcards.project_name,
            "microscopy_pixel_size",
            "project_name",
            read_sample_metadata(config["sample_metadata"]),
        ),
        IMC_location_spacing=lambda wildcards: get_column_entry_from_metadata(
            wildcards.project_name,
            "microscopy_pixel_size",
            "project_name",
            read_sample_metadata(config["sample_metadata"]),
        ),
        output_spacing=lambda wildcards: get_column_entry_from_metadata(
            wildcards.project_name,
            "microscopy_pixel_size",
            "project_name",
            read_sample_metadata(config["sample_metadata"]),
        ),
        transform_source="postIMC",
        transform_target="postIMS",
    input:
        postIMC_to_postIMS_transform=choose_postIMC_to_postIMS_transform,
        table_file="results/{project_name}/data/preIMS_location/available_masks.csv",
        postIMC="results/{project_name}/data/postIMC/{project_name}_postIMC.ome.tiff",
        IMC_location=lambda wildcards: f'results/{wildcards.project_name}/data/IMC_location/{wildcards.project_name}_registered_IMC_mask_on_postIMC_{get_column_entry_from_metadata_two_conditions(wildcards.sample,wildcards.project_name, "core_name", "sample_name","project_name", read_sample_metadata(config["sample_metadata"]))}.geojson',
    output:
        postIMC_transformed="results/{project_name}/data/postIMC/{sample}_transformed_on_postIMS.ome.tiff",
    log:
        stdout="logs/transform_postIMC_to_postIMS/{project_name}_{sample}.stdout",
    benchmark:
        "benchmarks/transform_postIMC_to_postIMS/{project_name}_{sample}.txt",
    container:
        config["container"]
    script:
        "scripts/transform_postIMC_to_postIMS.py"


rule transform_postIMC_to_preIMC:
    threads: 32
    resources:
        mem_mb=100000,
    params:
        input_spacing=lambda wildcards: get_column_entry_from_metadata(
            wildcards.project_name,
            "microscopy_pixel_size",
            "project_name",
            read_sample_metadata(config["sample_metadata"]),
        ),
        IMC_location_spacing=lambda wildcards: get_column_entry_from_metadata(
            wildcards.project_name,
            "microscopy_pixel_size",
            "project_name",
            read_sample_metadata(config["sample_metadata"]),
        ),
        output_spacing=lambda wildcards: get_column_entry_from_metadata(
            wildcards.project_name,
            "IMC_pixel_size",
            "project_name",
            read_sample_metadata(config["sample_metadata"]),
        ),
        transform_source="postIMC",
        transform_target="preIMC",
    input:
        postIMC_to_postIMS_transform=choose_postIMC_to_postIMS_transform,
        table_file="results/{project_name}/data/preIMS_location/available_masks.csv",
        postIMC="results/{project_name}/data/postIMC/{project_name}_postIMC.ome.tiff",
        IMC_location=lambda wildcards: f'results/{wildcards.project_name}/data/IMC_location/{wildcards.project_name}_registered_IMC_mask_on_postIMC_{get_column_entry_from_metadata_two_conditions(wildcards.sample,wildcards.project_name, "core_name", "sample_name","project_name", read_sample_metadata(config["sample_metadata"]))}.geojson',
    output:
        postIMC_transformed="results/{project_name}/data/postIMC/{sample}_transformed_on_preIMC.ome.tiff",
    log:
        stdout="logs/transform_postIMC_to_preIMC/{project_name}_{sample}.stdout",
    benchmark:
        "benchmarks/transform_postIMC_to_preIMC/{project_name}_{sample}.txt",
    container:
        config["container"]
    script:
        "scripts/transform_postIMC_to_postIMS.py"


rule transform_preIMC_to_preIMS:
    threads: 32
    resources:
        mem_mb=100000,
    params:
        input_spacing=lambda wildcards: get_column_entry_from_metadata(
            wildcards.project_name,
            "microscopy_pixel_size",
            "project_name",
            read_sample_metadata(config["sample_metadata"]),
        ),
        IMC_location_spacing=lambda wildcards: get_column_entry_from_metadata(
            wildcards.project_name,
            "microscopy_pixel_size",
            "project_name",
            read_sample_metadata(config["sample_metadata"]),
        ),
        output_spacing=lambda wildcards: get_column_entry_from_metadata(
            wildcards.project_name,
            "IMC_pixel_size",
            "project_name",
            read_sample_metadata(config["sample_metadata"]),
        ),
        transform_source="preIMC",
        transform_target="preIMS",
    input:
        postIMC_to_postIMS_transform=choose_postIMC_to_postIMS_transform,
        table_file="results/{project_name}/data/preIMS_location/available_masks.csv",
        postIMC="results/{project_name}/data/preIMC/{project_name}_preIMC.ome.tiff",
        IMC_location=lambda wildcards: f'results/{wildcards.project_name}/data/IMC_location/{wildcards.project_name}_IMC_mask_on_preIMC_{get_column_entry_from_metadata_two_conditions(wildcards.sample,wildcards.project_name, "core_name", "sample_name","project_name", read_sample_metadata(config["sample_metadata"]))}.geojson',
    output:
        postIMC_transformed="results/{project_name}/data/preIMC/{sample}_transformed_on_preIMS.ome.tiff",
    log:
        stdout="logs/transform_preIMC_to_preIMS/{project_name}_{sample}.stdout",
    benchmark:
        "benchmarks/transform_preIMC_to_preIMS/{project_name}_{sample}.txt",
    container:
        config["container"]
    script:
        "scripts/transform_postIMC_to_postIMS.py"


rule transform_preIMS_to_postIMS:
    threads: 32
    resources:
        mem_mb=100000,
    params:
        input_spacing=lambda wildcards: get_column_entry_from_metadata(
            wildcards.project_name,
            "microscopy_pixel_size",
            "project_name",
            read_sample_metadata(config["sample_metadata"]),
        ),
        IMC_location_spacing=lambda wildcards: get_column_entry_from_metadata(
            wildcards.project_name,
            "microscopy_pixel_size",
            "project_name",
            read_sample_metadata(config["sample_metadata"]),
        ),
        output_spacing=lambda wildcards: get_column_entry_from_metadata(
            wildcards.project_name,
            "IMC_pixel_size",
            "project_name",
            read_sample_metadata(config["sample_metadata"]),
        ),
        transform_source="preIMS",
        transform_target="postIMS",
    input:
        postIMC_to_postIMS_transform=choose_postIMC_to_postIMS_transform,
        table_file="results/{project_name}/data/preIMS_location/available_masks.csv",
        postIMC="results/{project_name}/data/preIMS/{project_name}_preIMS.ome.tiff",
        IMC_location=lambda wildcards: f'results/{wildcards.project_name}/data/IMC_location/{wildcards.project_name}_IMC_mask_on_preIMS_{get_column_entry_from_metadata_two_conditions(wildcards.sample,wildcards.project_name, "core_name", "sample_name","project_name", read_sample_metadata(config["sample_metadata"]))}.geojson',
    output:
        postIMC_transformed="results/{project_name}/data/preIMS/{sample}_transformed_on_postIMS.ome.tiff",
    log:
        stdout="logs/transform_preIMC_to_preIMS/{project_name}_{sample}.stdout",
    benchmark:
        "benchmarks/transform_preIMC_to_preIMS/{project_name}_{sample}.txt",
    container:
        config["container"]
    script:
        "scripts/transform_postIMC_to_postIMS.py"


rule downscale_postIMS:
    threads: 4
    resources:
        mem_mb=5000,
    params:
        input_spacing=lambda wildcards: get_column_entry_from_metadata(
            wildcards.project_name,
            "microscopy_pixel_size",
            "project_name",
            read_sample_metadata(config["sample_metadata"]),
        ),
        output_spacing=lambda wildcards: get_column_entry_from_metadata(
            wildcards.project_name,
            "microscopy_pixel_size",
            "project_name",
            read_sample_metadata(config["sample_metadata"]),
        ),
    input:
        postIMS="results/{project_name}/data/postIMS/{project_name}_postIMS.ome.tiff",
        #IMC_transformed=lambda wildcards: expand(
        #    "results/{{project_name}}/data/IMC_mask/{sample}_transformed_on_postIMS.ome.tiff",
        #    sample=get_column_entry_from_metadata(
        #        wildcards.project_name,
        #        "sample_name",
        #        "project_name",
        #        read_sample_metadata(config["sample_metadata"]),
        #        return_all=True,
        #    ),
        #),
    output:
        postIMS_downscaled="results/{project_name}/data/postIMS/{project_name}_postIMS_reduced.ome.tiff",
    log:
        stdout="logs/downscale_postIMS/{project_name}.stdout",
    benchmark:
        "benchmarks/downscale_postIMS/{project_name}.txt",
    container:
        config["container"]
    script:
        "scripts/downscale_image.py"


use rule downscale_postIMS as downscale_preIMS with:
    input:
        postIMS="results/{project_name}/data/preIMS/{project_name}-preIMS_to_postIMS_registered.ome.tiff",
        IMC_transformed=lambda wildcards: expand(
            "results/{{project_name}}/data/IMC_mask/{sample}_transformed_on_postIMS.ome.tiff",
            sample=get_column_entry_from_metadata(
                wildcards.project_name,
                "sample_name",
                "project_name",
                read_sample_metadata(config["sample_metadata"]),
                return_all=True,
            ),
        ),
    output:
        postIMS_downscaled="results/{project_name}/data/preIMS/{project_name}-preIMS_to_postIMS_registered_reduced.ome.tiff",
    log:
        stdout="logs/downscale_preIMS/{project_name}.stdout",
    benchmark:
        "benchmarks/downscale_preIMS/{project_name}.txt",


use rule downscale_postIMS as downscale_preIMC with:
    input:
        postIMS="results/{project_name}/data/preIMC/{project_name}-preIMC_to_postIMS_registered.ome.tiff",
        IMC_transformed=lambda wildcards: expand(
            "results/{{project_name}}/data/IMC_mask/{sample}_transformed_on_postIMS.ome.tiff",
            sample=get_column_entry_from_metadata(
                wildcards.project_name,
                "sample_name",
                "project_name",
                read_sample_metadata(config["sample_metadata"]),
                return_all=True,
            ),
        ),
    output:
        postIMS_downscaled="results/{project_name}/data/preIMC/{project_name}-preIMC_to_postIMS_registered_reduced.ome.tiff",
    log:
        stdout="logs/downscale_preIMC/{project_name}.stdout",
    benchmark:
        "benchmarks/downscale_preIMC/{project_name}.txt",

