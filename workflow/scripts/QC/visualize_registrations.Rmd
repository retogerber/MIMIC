---
title: "Visualize Filtering"
author: ""
date: "`r Sys.Date()`"
output:
  html_document:
    self_contained: FALSE 
    code_folding: "hide"
    toc: true
    toc_float: true 
    toc_collapsed: true
    css: "style.css"
toc_depth: 3
number_sections: true
theme: lumen
editor_options:
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(knitr)
```

```{r}
suppressPackageStartupMessages({
library(ggplot2)
library(ggnewscale)
})
```
```{r}
basedir <- getwd()
# basedir <- "."
# tmp <- "results/{project_name}/data/registration_metric/report/{project_name}_registration_evaluation.html"
# basedir <- Reduce(file.path, rep("..",length(strsplit(dirname(snakemake@output[["html"]]),"/")[[1]])))
generic_input <- snakemake@params[["generic_input"]]

input_csv_files <- snakemake@input[["registration_metrics_combined"]]
project_name <- basename(dirname(dirname(dirname(input_csv_files))))
sample_names <- read.csv(input_csv_files[1])$sample

IMS_to_postIMS_svg <- sapply(snakemake@input[["IMS_to_postIMS_svg"]], function(s) file.path(basedir, s))

IMS_to_postIMS_png <- sapply(snakemake@input[["IMS_to_postIMS_png"]], function(s) file.path(basedir, s))

preIMSmask_to_postIMSmask_png <- sapply(snakemake@input[["preIMSmask_to_postIMSmask_png"]], function(s) file.path(basedir, s))

preIMCmask_to_preIMSmask_png <- sapply(snakemake@input[["preIMCmask_to_preIMSmask_png"]], function(s) file.path(basedir, s))

postIMCmask_to_preIMCmask_png <- sapply(snakemake@input[["postIMCmask_to_preIMCmask_png"]], function(s) file.path(basedir, s))

postIMCmask_to_postIMSmask_png <- sapply(snakemake@input[["postIMCmask_to_postIMSmask_png"]], function(s) file.path(basedir, s))

landmarks_postIMC_transformed_on_preIMC_png <- sapply(snakemake@input[["landmarks_postIMC_transformed_on_preIMC_png"]], function(s) file.path(basedir, s))
landmarks_preIMC_png <- sapply(snakemake@input[["landmarks_preIMC_png"]], function(s) file.path(basedir, s))

landmarks_preIMC_transformed_on_preIMS_png <- sapply(snakemake@input[["landmarks_preIMC_transformed_on_preIMS_png"]], function(s) file.path(basedir, s))
landmarks_preIMS_png <- sapply(snakemake@input[["landmarks_preIMS_png"]], function(s) file.path(basedir, s))

landmarks_preIMS_transformed_on_postIMS_png <- sapply(snakemake@input[["landmarks_preIMS_transformed_on_postIMS_png"]], function(s) file.path(basedir, s))
landmarks_postIMS_png <- sapply(snakemake@input[["landmarks_postIMS_png"]], function(s) file.path(basedir, s))

landmarks_postIMC_transformed_on_postIMS_png <- sapply(snakemake@input[["landmarks_postIMC_transformed_on_postIMS_png"]], function(s) file.path(basedir, s))
landmarks_postIMS_to_postIMC_png <- sapply(snakemake@input[["landmarks_postIMS_to_postIMC_png"]], function(s) file.path(basedir, s))

regions_postIMC_transformed_on_preIMC_png <- sapply(snakemake@input[["regions_postIMC_transformed_on_preIMC_png"]], function(s) file.path(basedir, s))
regions_preIMC_transformed_on_preIMS_png <- sapply(snakemake@input[["regions_preIMC_transformed_on_preIMS_png"]], function(s) file.path(basedir, s))
regions_preIMS_transformed_on_postIMS_png <- sapply(snakemake@input[["regions_preIMS_transformed_on_postIMS_png"]], function(s) file.path(basedir, s))
regions_postIMC_transformed_on_postIMS_png <- sapply(snakemake@input[["regions_postIMC_transformed_on_postIMS_png"]], function(s) file.path(basedir, s))

gif_postIMC_preIMC <- sapply(snakemake@input[["gif_postIMC_preIMC"]], function(s) file.path(basedir, s))
gif_postIMC_postIMS <- sapply(snakemake@input[["gif_postIMC_postIMS"]], function(s) file.path(basedir, s))
gif_preIMC_preIMS <- sapply(snakemake@input[["gif_preIMC_preIMS"]], function(s) file.path(basedir, s))
gif_preIMS_postIMS <- sapply(snakemake@input[["gif_preIMS_postIMS"]], function(s) file.path(basedir, s))
IMC_location_extraction_image <- sapply(snakemake@input[["IMC_location_extraction_image"]], function(s) file.path(basedir, s))
plot_IMC_to_preIMC <- sapply(snakemake@input[["IMC_to_preIMC_plot"]], function(s) file.path(basedir, s))
```


```{r, eval=FALSE}
basedir <- "/home/retger/Nextcloud/Projects/test_imc_to_ims_workflow/imc_to_ims_workflow"
# project_name <- "test_combined"
# sample_names <- c("Cirrhosis-TMA-5_New_Detector_001", "Cirrhosis-TMA-5_New_Detector_002")
input_csv_files <- "results/cirrhosis_TMA/data/registration_metric/cirrhosis_TMA_reg_metrics_combined.csv"
input_csv_files <- "/home/retger/Downloads/cirrhosis_TMA_reg_metrics_combined.csv"
input_csv_files <- c("/home/retger/Nextcloud/Projects/test_imc_to_ims_workflow/imc_to_ims_workflow/results/test_combined/data/registration_metric/test_combined_reg_metrics_combined.csv")
input_csv_files <- "/home/retger/IMC/data/complete_analysis_imc_workflow/imc_to_ims_workflow/results/NASH_HCC_TMA/data/registration_metric/NASH_HCC_TMA_reg_metrics_combined.csv"
input_csv_files <- "/home/retger/IMC/data/complete_analysis_imc_workflow/imc_to_ims_workflow_biopsies/results/id1007966/data/registration_metric/id1007966_reg_metrics_combined.csv"
vis_type <- "IMS_to_postIMS"
```

```{r}
summary_dt <- function(input_csv_files, vis_type) {
  df <- read.csv(input_csv_files)
  colname_reg <- paste0(vis_type, "_")
  b1 <- stringr::str_detect(colnames(df), paste0("(^", vis_type, ")|(_", vis_type, ")"))
  t1 <- stringr::str_replace(vis_type, "_to_", "_")
  b2 <- stringr::str_detect(colnames(df), paste0("(^", t1, ")|(_", t1, ")"))
  b3 <- colnames(df) %in% c("sample", "project")
  df <- df[, b1 | b2 | b3]
  colnames(df) <- stringr::str_replace(colnames(df), paste0(vis_type, "_"), "")
  colnames(df) <- stringr::str_replace(colnames(df), paste0("_", vis_type), "")
  colnames(df) <- stringr::str_replace(colnames(df), paste0("_", stringr::str_replace(vis_type, "_to_", "_")), "")

  if (vis_type == "IMS_to_postIMS") {
    df$Completeness <- df$n_points / df$n_points_total
  }
  colnames(df)
  for (col in colnames(df)) {
    if (col != "sample" & col != "project") {
      df[[col]] <- signif(as.numeric(df[[col]]), 3)
    }
  }
  colnames(df) <- stringr::str_replace_all(colnames(df), "_", " ")

  knitr::kable(df)
}
```

```{r}
pairs_plot <- function(input_csv_files, vis_type, quantile_type = "quantile50", return_missing = FALSE) {
  stopifnot(quantile_type %in% c("mean", "quantile05", "quantile25", "quantile50", "quantile75", "quantile95", "min", "max"))
  df <- read.csv(input_csv_files)
  colname_reg <- paste0(vis_type, "_")
  b1 <- stringr::str_detect(colnames(df), paste0("(^", vis_type, ")|(_", vis_type, ")"))
  t1 <- stringr::str_replace(vis_type, "_to_", "_")
  b2 <- stringr::str_detect(colnames(df), paste0("(^", t1, ")|(_", t1, ")"))
  b3 <- colnames(df) %in% c("sample", "project")
  df <- df[, b1 | b2 | b3]
  colnames(df) <- stringr::str_replace(colnames(df), paste0(vis_type, "_"), "")
  colnames(df) <- stringr::str_replace(colnames(df), paste0("_", vis_type), "")
  colnames(df) <- stringr::str_replace(colnames(df), paste0("_", stringr::str_replace(vis_type, "_to_", "_")), "")

  if (vis_type == "IMS_to_postIMS") {
    df$Completeness <- df$n_points / df$n_points_total
  }
  d <- plotly::highlight_key(df, ~sample)
  base <- plotly::plot_ly(
    d,
    text = ~sample,
    # hoverinfo = "text",
    type = "scatter",
    mode = "markers",
    # color = 1,
    # colors = "Set1",
    marker = list(size = 10),
    showlegend = FALSE
  )
  pltls <- list()
  ismissing <- list(
    tissue_masks = rep(FALSE, nrow(df)),
    landmarks = rep(FALSE, nrow(df)),
    regions = rep(FALSE, nrow(df)),
    metrics = rep(FALSE, nrow(df))
  )
  if ("structural_similarity" %in% colnames(df) & 
    "mean_squared_error" %in% colnames(df) &
    "normalized_mutual_information" %in% colnames(df) &
    "normalized_root_mean_squared_error" %in% colnames(df) 
    ) {
    ismissing[["metrics"]] <- is.na(df$structural_similarity) | 
      is.na(df$mean_squared_error) | 
      is.na(df$normalized_mutual_information) | 
      is.na(df$normalized_root_mean_squared_error)
    
    tmp_add_plotly_conf <- function(x,name1,name2){
      x |>
      plotly::layout(
        xaxis = list(title = ""),
        yaxis = list(title = name1)
      ) |>
      plotly::add_annotations(
        text = name2,
        x = 0.5,
        y = 1,
        yref = "paper",
        xref = "paper",
        xanchor = "middle",
        yanchor = "top",
        showarrow = FALSE,
        font = list(size = 15)
      )
    }
    ssimplt <-
      plotly::add_markers(base,
        y = ~structural_similarity,
        x = ~jitter(1),
        marker = list(color = "rgb(0,0,0)"),
        hovertemplate = paste0("<b>%{text}</b><br>SSIM: %{y:.2f}")
      ) |>
      tmp_add_plotly_conf("Structural similarity", "SSIM")
    mseplt <-
      plotly::add_markers(base,
        y = ~mean_squared_error,
        x = ~jitter(1),
        marker = list(color = "rgb(0,0,0)"),
        hovertemplate = paste0("<b>%{text}</b><br>MSE: %{y:.2f}")
      ) |>
      tmp_add_plotly_conf("Mean squared error", "MSE")
    nmiplt <-
      plotly::add_markers(base,
        y = ~normalized_mutual_information,
        x = ~jitter(1),
        marker = list(color = "rgb(0,0,0)"),
        hovertemplate = paste0("<b>%{text}</b><br>NMI: %{y:.2f}")
      ) |>
      tmp_add_plotly_conf("Normalized mutual information", "NMI")
    nrmseplt <-
      plotly::add_markers(base,
        y = ~normalized_root_mean_squared_error,
        x = ~jitter(1),
        marker = list(color = "rgb(0,0,0)"),
        hovertemplate = paste0("<b>%{text}</b><br>NRMSE: %{y:.2f}")
      ) |>
      tmp_add_plotly_conf("Normalized root mean squared error", "NRMSE")
    
    metrics_plt <- plotly::subplot(
      list(ssimplt, mseplt, nmiplt, nrmseplt),
      nrows=2,
      titleX = TRUE,
      titleY = TRUE,
      margin=0.05
    )     
    pltls <- c(pltls, list(metrics_plt))
  }
  if ("euclidean_distance_centroids" %in% colnames(df) & "dice_score" %in% colnames(df)) {
    ismissing[["tissue_masks"]] <- is.na(df$euclidean_distance_centroids) | is.na(df$dice_score)
    masks_plt <-
      plotly::add_markers(base,
        x = ~euclidean_distance_centroids,
        y = ~dice_score,
        marker = list(color = "rgb(0,0,0)"),
        hovertemplate = paste0("<b>%{text}</b><br>Error: %{x:.2f}<br>Dice: %{y:.2f}")
      ) |>
      plotly::layout(
        xaxis = list(range = c(0, max(df$euclidean_distance_centroids) * 1.1), title = "Distance between centroids"),
        yaxis = list(range = c(0, 1.1), title = "Dice coefficient")
      ) |>
      plotly::add_annotations(
        text = "Tissue masks",
        x = 0.5,
        y = 1,
        yref = "paper",
        xref = "paper",
        xanchor = "middle",
        yanchor = "top",
        showarrow = FALSE,
        font = list(size = 15)
      )
    pltls <- c(pltls, list(masks_plt))
  }
  axis_type <- paste0(quantile_type, "_error")
  if (axis_type %in% colnames(df) & "n_points_total" %in% colnames(df)) {
    if (vis_type == "IMS_to_postIMS") {
      yaxis_type <- "Completeness"
      yaxis_title <- "Proportion of detected ablation marks"
      y_legend <- "Proportion"
    } else {
      yaxis_type <- "n_points_total"
      yaxis_title <- "Number of landmarks"
      y_legend <- "N landmarks"
    }
    ismissing[["landmarks"]] <- is.na(df[[axis_type]]) | is.na(df[[yaxis_type]])
    landmarks_plt <-
      plotly::add_markers(base,
        x = dplyr::quo(!!dplyr::sym(axis_type)),
        y = dplyr::quo(!!dplyr::sym(yaxis_type)),
        marker = list(color = "rgb(0,0,0)"),
        hovertemplate = sprintf("<b>%%{text}</b><br>Error: %%{x:.2f}<br>%s: %%{y:.2f}", y_legend)
      ) |>
      plotly::layout(
        xaxis = list(range = c(0, max(df[[axis_type]]) * 1.1), title = "Distance between landmarks"),
        yaxis = list(range = c(0, max(df[[yaxis_type]]) * 1.1), title = yaxis_title)
      ) |>
      plotly::add_annotations(
        text = "Landmarks",
        x = 0.5,
        y = 1,
        yref = "paper",
        xref = "paper",
        xanchor = "middle",
        yanchor = "top",
        showarrow = FALSE,
        font = list(size = 15)
      )
    pltls <- c(pltls, list(landmarks_plt))
  }

  xaxis_type <- paste0("regions_", quantile_type, "_error")
  yaxis_type <- switch(quantile_type,
    "mean" = "regions_mean_dice",
    "quantile05" = "regions_quantile95_dice",
    "quantile25" = "regions_quantile75_dice",
    "quantile50" = "regions_quantile50_dice",
    "quantile75" = "regions_quantile25_dice",
    "quantile95" = "regions_quantile05_dice",
    "min" = "regions_max_dice",
    "max" = "regions_min_dice"
  )
  if (xaxis_type %in% colnames(df) & yaxis_type %in% colnames(df) & "regions_n_points_total" %in% colnames(df)) {
    ismissing[["regions"]] <- is.na(df[[xaxis_type]]) | is.na(df[[yaxis_type]])
    regions_plt <-
      plotly::add_markers(base,
        x = dplyr::quo(!!dplyr::sym(xaxis_type)),
        y = dplyr::quo(!!dplyr::sym(yaxis_type)),
        color = ~regions_n_points_total,
        text = ~regions_n_points_total,
        hovertemplate = paste0("<b>%{text}</b><br>Error: %{x:.2f}<br>Dice: %{y:.2f}<br>N regions: %{text}")
      ) |>
      plotly::layout(
        xaxis = list(range = c(0, max(df[[xaxis_type]]) * 1.1), title = "Distance between regions"),
        yaxis = list(range = c(0, 1.1), title = "Dice coefficient")
      ) |>
      plotly::add_annotations(
        text = "Regions",
        x = 0.5,
        y = 1,
        yref = "paper",
        xref = "paper",
        xanchor = "middle",
        yanchor = "top",
        showarrow = FALSE,
        font = list(size = 15)
      )
    pltls <- c(pltls, list(regions_plt))
  }
  if (length(pltls) > 0) {
    if ("structural_similarity" %in% colnames(df)){
      fig <- plotly::subplot(
        pltls,
        widths = c(2, rep(1, length(pltls) - 1))/(length(pltls) + 1),
        titleX = TRUE,
        titleY = TRUE
      ) 
    } else{
      fig <- plotly::subplot(
        pltls,
        titleX = TRUE,
        titleY = TRUE
      ) 
    }
    fig <- fig |>
      plotly::highlight(on = "plotly_hover", off = "plotly_doubleclick")
    if (return_missing) {
      missing_df <- data.frame(
        sample = df$sample,
        tissue_masks = ismissing[["tissue_masks"]],
        landmarks = ismissing[["landmarks"]],
        regions = ismissing[["regions"]]
      )
      return(list(fig, missing_df))
    } else {
      return(fig)
    }
  } else {
    return(NULL)
  }
}
```


```{r}
sitk_error_plot <- function(input_csv_files, vis_type = "preIMS_to_postIMS") {
  colname_reg <- paste0(vis_type, "_")

  dfls <- lapply(input_csv_files, function(x) {
    df <- read.csv(x)
    df$project <- stringr::str_replace(basename(x), "_reg_metrics_combined.csv", "")
    df <- df[, grepl(colname_reg, colnames(df)) | colnames(df) %in% c("sample", "project")]

    colnames(df) <- stringr::str_replace(colnames(df), colname_reg, "")
    colnames(df) <- stringr::str_replace(colnames(df), "quantile", "Q")
    df
  })
  df <- Reduce(rbind, dfls)

  # df$global_shift <- sqrt(colSums(rbind(df$global_x_shift**2, df$global_y_shift**2)))
  df$global_shift <- df$mean_error
  df$sitk_global_shift <- sqrt(colSums(rbind(df$sitk_global_x_shift**2, df$sitk_global_y_shift**2)))


  global_range <- range(unlist(lapply(colnames(df)[grepl("_shift", colnames(df))], function(x) df[[x]])))
  global_range[1] <- global_range[1] - 1
  global_range[2] <- global_range[2] + 1

  d <- plotly::highlight_key(df, ~sample)
  base <- plotly::plot_ly(
    d,
    text = ~sample,
    # hoverinfo = "text",
    type = "scatter",
    mode = "markers",
    color = ~project,
    colors = "Set1",
    marker = list(size = 10),
    showlegend = FALSE
  )
  fig <- plotly::subplot(
    plotly::add_markers(base,
      x = ~global_x_shift, y = ~sitk_global_x_shift,
      hovertemplate = paste0("<b>%{text}</b><br>X error Landmarks: %{y:.2f}<br>X error sitk: %{x:.2f}")
    ) |>
      plotly::layout(
        xaxis = list(range = global_range, title = "X translation"),
        yaxis = list(range = global_range, title = "X translation sitk")
      ),
    plotly::add_markers(base,
      x = ~global_y_shift, y = ~sitk_global_y_shift,
      hovertemplate = paste0("<b>%{text}</b><br>Y error Landmarks: %{y:.2f}<br>Y error sitk: %{x:.2f}")
    ) |>
      plotly::layout(
        xaxis = list(range = global_range, title = "Y translation"),
        yaxis = list(range = global_range, title = "Y translation sitk")
      ),
    plotly::add_markers(base,
      x = ~global_shift, y = ~sitk_global_shift,
      hovertemplate = paste0("<b>%{text}</b><br>Error Landmarks: %{y:.2f}<br>Error sitk: %{x:.2f}")
    ) |>
      plotly::layout(
        xaxis = list(title = "translation"),
        yaxis = list(title = "translation sitk")
      )
  ) |>
    plotly::add_annotations(
      text = "X translation",
      x = 0.15,
      y = 1,
      yref = "paper",
      xref = "paper",
      yanchor = "bottom",
      showarrow = FALSE,
      font = list(size = 15)
    ) |>
    plotly::add_annotations(
      text = "Y translation",
      x = 0.5,
      y = 1,
      yref = "paper",
      xref = "paper",
      yanchor = "bottom",
      showarrow = FALSE,
      font = list(size = 15)
    ) |>
    plotly::add_annotations(
      text = "Error",
      x = 0.85,
      y = 1,
      yref = "paper",
      xref = "paper",
      yanchor = "bottom",
      showarrow = FALSE,
      font = list(size = 15)
    ) |>
    plotly::layout(
      xaxis = list(title = "Landmarks"),
      yaxis = list(title = "sitk"),
      margin = list(t = 50, b = 150, l = 50, r = 50)
    ) |>
    plotly::highlight(on = "plotly_hover", off = "plotly_doubleclick")
  fig
}
```

```{r plot_images, results='asis', fig.width=8, fig.height=8, eval=FALSE, echo=FALSE}
cat("\n\n")
for (i in seq_along(filenames)) {
  filename <- filenames[i]
  if (file.exists(filename)) {
    cat(sprintf("\n\n#### %s\n\n", sample_names[i]))
    cat(sprintf("<img src=\"%s\" alt=\"%s\" height=\"%s\"/>", filename, filename, img_height))
  }
}
cat("\n\n")
```

```{r plot_2_images, results='asis', fig.width=8, fig.height=8, eval=FALSE, echo=FALSE}
cat("\n\n")
for (i in seq_along(filenames1)) {
  filename1 <- filenames1[i]
  filename2 <- filenames2[i]
  if (file.exists(filename1) & file.exists(filename2)) {
    cat(sprintf("\n\n#### %s\n\n", sample_names[i]))
    cat("<p float=\"left\">")
    cat(sprintf("<img src=\"%s\" alt=\"%s\" width=\"50%%\"/>", filename1, filename1))
    cat(sprintf("<img src=\"%s\" alt=\"%s\" width=\"50%%\"/>", filename2, filename2))
    cat("</p>")
  }
}
cat("\n\n")
```


```{r pairs_plots, results='asis', fig.width=16, fig.height=8, echo=FALSE, eval=FALSE}
cat(sprintf("\n\n### %s\n\n", "quantile50"))
tmp <- pairs_plot(input_csv_files, vis_type, "quantile50", return_missing = TRUE)
tmp[[1]]
is_missing <- tmp[[2]]$tissue_masks | tmp[[2]]$landmarks | tmp[[2]]$regions
if (sum(is_missing) > 0) {
  cat("\n\n")
  knitr::kable(tmp[[2]][is_missing, ])
}
cat(sprintf("\n\n### %s\n\n", "mean"))
tmp <- pairs_plot(input_csv_files, vis_type, "mean", return_missing = TRUE)
tmp[[1]]
is_missing <- tmp[[2]]$tissue_masks | tmp[[2]]$landmarks | tmp[[2]]$regions
if (sum(is_missing) > 0) {
  cat("\n\n")
  knitr::kable(tmp[[2]][is_missing, ])
}
cat(sprintf("\n\n### %s\n\n", "quantile05"))
tmp <- pairs_plot(input_csv_files, vis_type, "quantile05", return_missing = TRUE)
tmp[[1]]
is_missing <- tmp[[2]]$tissue_masks | tmp[[2]]$landmarks | tmp[[2]]$regions
if (sum(is_missing) > 0) {
  cat("\n\n")
  knitr::kable(tmp[[2]][is_missing, ])
}
cat(sprintf("\n\n### %s\n\n", "quantile95"))
tmp <- pairs_plot(input_csv_files, vis_type, "quantile95", return_missing = TRUE)
tmp[[1]]
is_missing <- tmp[[2]]$tissue_masks | tmp[[2]]$landmarks | tmp[[2]]$regions
if (sum(is_missing) > 0) {
  cat("\n\n")
  knitr::kable(tmp[[2]][is_missing, ])
}
cat(sprintf("\n\n### %s\n\n", "min"))
tmp <- pairs_plot(input_csv_files, vis_type, "min", return_missing = TRUE)
tmp[[1]]
is_missing <- tmp[[2]]$tissue_masks | tmp[[2]]$landmarks | tmp[[2]]$regions
if (sum(is_missing) > 0) {
  cat("\n\n")
  knitr::kable(tmp[[2]][is_missing, ])
}
cat(sprintf("\n\n### %s\n\n", "max"))
tmp <- pairs_plot(input_csv_files, vis_type, "max", return_missing = TRUE)
tmp[[1]]
is_missing <- tmp[[2]]$tissue_masks | tmp[[2]]$landmarks | tmp[[2]]$regions
if (sum(is_missing) > 0) {
  cat("\n\n")
  knitr::kable(tmp[[2]][is_missing, ])
}
cat("\n\n")
```

# Overview
```{r}
min_completenes <- 0.1
min_landmarks <- 50
min_regions <- 2
min_q50_error <- 5
min_q50_dice <- 0.7
```
```{r}
df <- read.csv(input_csv_files)

to_keep_df <- data.frame(
  sample = df$sample
)

if("IMS_to_postIMS" %in% snakemake@params[["QC_steps"]]){
  df$IMS_Completeness <- df$IMS_to_postIMS_n_points / df$IMS_to_postIMS_n_points_total

  IMS_error_thr <- median(df$IMS_to_postIMS_quantile50_error) + 3 * mad(df$IMS_to_postIMS_quantile50_error)
  keep_IMS_to_postIMS <- df$IMS_Completeness > min_completenes & df$IMS_to_postIMS_quantile50_error < IMS_error_thr
  to_keep_df$keep_IMS_to_postIMS <- keep_IMS_to_postIMS
} else{
  keep_IMS_to_postIMS <- rep(NA, length(df$sample))
  to_keep_df$keep_IMS_to_postIMS <- keep_IMS_to_postIMS
}

## postIMC to postIMS
### landmarks
if("postIMC_to_postIMS" %in% snakemake@params[["QC_steps"]] & "landmarks" %in% snakemake@params[["QC_metrics"]]){
  postIMCpostIMS_lm <- rep(NA, length(df$sample))
  postIMCpostIMS_lm[df$postIMC_to_postIMS_n_points_total > min_landmarks] <- df$postIMC_to_postIMS_quantile50_error[df$postIMC_to_postIMS_n_points_total > min_landmarks] < min_q50_error
  to_keep_df$postIMCpostIMS_lm <- postIMCpostIMS_lm
}
### regions
if("postIMC_to_postIMS" %in% snakemake@params[["QC_steps"]] & "regions" %in% snakemake@params[["QC_metrics"]]){
  postIMCpostIMS_reg <- rep(NA, length(df$sample))
  postIMCpostIMS_reg[df$postIMC_to_postIMS_regions_n_points_total > min_regions] <-
    df$postIMC_to_postIMS_regions_quantile50_error[df$postIMC_to_postIMS_regions_n_points_total > min_regions] < min_q50_error &
      df$postIMC_to_postIMS_regions_quantile50_dice[df$postIMC_to_postIMS_regions_n_points_total > min_regions] > min_q50_dice
  to_keep_df$postIMCpostIMS_reg <- postIMCpostIMS_reg
}

## preIMS to postIMS
### landmarks
if("preIMS_to_postIMS" %in% snakemake@params[["QC_steps"]] & "landmarks" %in% snakemake@params[["QC_metrics"]]){
  preIMSpostIMS_lm <- rep(NA, length(df$sample))
  preIMSpostIMS_lm[df$preIMS_to_postIMS_n_points_total > min_landmarks] <- df$preIMS_to_postIMS_quantile50_error[df$preIMS_to_postIMS_n_points_total > min_landmarks] < min_q50_error
  to_keep_df$preIMSpostIMS_lm <- preIMSpostIMS_lm
}

### regions
if("preIMS_to_postIMS" %in% snakemake@params[["QC_steps"]] & "regions" %in% snakemake@params[["QC_metrics"]]){
  preIMSpostIMS_reg <- rep(NA, length(df$sample))
  preIMSpostIMS_reg[df$preIMS_to_postIMS_regions_n_points_total > min_regions] <-
    df$preIMS_to_postIMS_regions_quantile50_error[df$preIMS_to_postIMS_regions_n_points_total > min_regions] < min_q50_error |
      df$preIMS_to_postIMS_regions_quantile50_dice[df$preIMS_to_postIMS_regions_n_points_total > min_regions] > min_q50_dice
  to_keep_df$preIMSpostIMS_reg <- preIMSpostIMS_reg
}

### sitk
if("preIMS_to_postIMS" %in% snakemake@params[["QC_steps"]] & "sitk" %in% snakemake@params[["QC_metrics"]]){
  preIMSpostIMS_sitk <- sqrt(df$preIMS_to_postIMS_sitk_global_x_shift**2 + df$preIMS_to_postIMS_sitk_global_y_shift**2) < min_q50_error
  to_keep_df$preIMSpostIMS_sitk <- preIMSpostIMS_sitk
}

## preIMC to preIMS
### landmarks
if("preIMC_to_preIMS" %in% snakemake@params[["QC_steps"]] & "landmarks" %in% snakemake@params[["QC_metrics"]]){
  preIMCpreIMS_lm <- rep(NA, length(df$sample))
  preIMCpreIMS_lm[df$preIMC_to_preIMS_n_points_total > min_landmarks] <- df$preIMC_to_preIMS_quantile50_error[df$preIMC_to_preIMS_n_points_total > min_landmarks] < min_q50_error
  to_keep_df$preIMCpreIMS_lm <- preIMCpreIMS_lm
}

### regions
if("preIMC_to_preIMS" %in% snakemake@params[["QC_steps"]] & "regions" %in% snakemake@params[["QC_metrics"]]){
  preIMCpreIMS_reg <- rep(NA, length(df$sample))
  preIMCpreIMS_reg[df$preIMC_to_preIMS_regions_n_points_total > min_regions] <-
    df$preIMC_to_preIMS_regions_quantile50_error[df$preIMC_to_preIMS_regions_n_points_total > min_regions] < min_q50_error |
      df$preIMC_to_preIMS_regions_quantile50_dice[df$preIMC_to_preIMS_regions_n_points_total > min_regions] > min_q50_dice
  to_keep_df$preIMCpreIMS_reg <- preIMCpreIMS_reg
}

## postIMC to preIMC
### landmarks
if("postIMC_to_preIMC" %in% snakemake@params[["QC_steps"]] & "landmarks" %in% snakemake@params[["QC_metrics"]]){
  postIMCpreIMC_lm <- rep(NA, length(df$sample))
  postIMCpreIMC_lm[df$postIMC_to_preIMC_n_points_total > min_landmarks] <- df$postIMC_to_preIMC_quantile50_error[df$postIMC_to_preIMC_n_points_total > min_landmarks] < min_q50_error
  to_keep_df$postIMCpreIMC_lm <- postIMCpreIMC_lm
}

### regions
if("postIMC_to_preIMC" %in% snakemake@params[["QC_steps"]] & "regions" %in% snakemake@params[["QC_metrics"]]){
  postIMCpreIMC_reg <- rep(NA, length(df$sample))
  postIMCpreIMC_reg[df$postIMC_to_preIMC_regions_n_points_total > min_regions] <-
    df$postIMC_to_preIMC_regions_quantile50_error[df$postIMC_to_preIMC_regions_n_points_total > min_regions] < min_q50_error |
      df$postIMC_to_preIMC_regions_quantile50_dice[df$postIMC_to_preIMC_regions_n_points_total > min_regions] > min_q50_dice
  to_keep_df$postIMCpreIMC_reg <- postIMCpreIMC_reg
}
```

```{r}
## postIMC to postIMS
if("postIMCpostIMS_lm" %in% colnames(to_keep_df) & "postIMCpostIMS_reg" %in% colnames(to_keep_df)){
  postIMC_to_postIMS <- ifelse(is.na(postIMCpostIMS_lm), FALSE, postIMCpostIMS_lm) | ifelse(is.na(postIMCpostIMS_reg), FALSE, postIMCpostIMS_reg)
  postIMC_to_postIMS[!postIMC_to_postIMS][is.na(postIMCpostIMS_lm[!postIMC_to_postIMS]) & is.na(postIMCpostIMS_reg[!postIMC_to_postIMS])] <- NA
} else if ("postIMCpostIMS_lm" %in% colnames(to_keep_df)){ 
  postIMC_to_postIMS <- postIMCpostIMS_lm
} else if ("postIMCpostIMS_reg" %in% colnames(to_keep_df)){ 
  postIMC_to_postIMS <- postIMCpostIMS_reg
}

## preIMS to postIMS
if("preIMSpostIMS_lm" %in% colnames(to_keep_df) & "preIMSpostIMS_reg" %in% colnames(to_keep_df) & "preIMSpostIMS_sitk" %in% colnames(to_keep_df)){
  preIMS_to_postIMS <- ifelse(is.na(preIMSpostIMS_lm), FALSE, preIMSpostIMS_lm) | ifelse(is.na(preIMSpostIMS_reg), FALSE, preIMSpostIMS_reg) | ifelse(is.na(preIMSpostIMS_sitk), FALSE, preIMSpostIMS_sitk)
  preIMS_to_postIMS[!preIMS_to_postIMS][is.na(preIMSpostIMS_lm[!preIMS_to_postIMS]) & is.na(preIMSpostIMS_reg[!preIMS_to_postIMS])] <- NA
} else if ("preIMSpostIMS_lm" %in% colnames(to_keep_df)){ 
  preIMS_to_postIMS <- preIMSpostIMS_lm
} else if ("preIMSpostIMS_reg" %in% colnames(to_keep_df)){ 
  preIMS_to_postIMS <- preIMSpostIMS_reg
} else if ("preIMSpostIMS_sitk" %in% colnames(to_keep_df)){ 
  preIMS_to_postIMS <- preIMSpostIMS_sitk
} else{
  preIMS_to_postIMS <- rep(NA, length(df$sample))
}

## preIMC to preIMS
if("preIMCpreIMS_lm" %in% colnames(to_keep_df) & "preIMCpreIMS_reg" %in% colnames(to_keep_df)){
  preIMC_to_preIMS <- ifelse(is.na(preIMCpreIMS_lm), FALSE, preIMCpreIMS_lm) | ifelse(is.na(preIMCpreIMS_reg), FALSE, preIMCpreIMS_reg)
  preIMC_to_preIMS[!preIMC_to_preIMS][is.na(preIMCpreIMS_lm[!preIMC_to_preIMS]) & is.na(preIMCpreIMS_reg[!preIMC_to_preIMS])] <- NA
} else if ("preIMCpreIMS_lm" %in% colnames(to_keep_df)){ 
  preIMC_to_preIMS <- preIMCpreIMS_lm
} else if ("preIMCpreIMS_reg" %in% colnames(to_keep_df)){ 
  preIMC_to_preIMS <- preIMCpreIMS_reg
} else{
  preIMC_to_preIMS <- rep(NA, length(df$sample))
}

## postIMC to preIMC
if("postIMCpreIMC_lm" %in% colnames(to_keep_df) & "postIMCpreIMC_reg" %in% colnames(to_keep_df)){
  postIMC_to_preIMC <- ifelse(is.na(postIMCpreIMC_lm), FALSE, postIMCpreIMC_lm) | ifelse(is.na(postIMCpreIMC_reg), FALSE, postIMCpreIMC_reg)
  postIMC_to_preIMC[!postIMC_to_preIMC][is.na(postIMCpreIMC_lm[!postIMC_to_preIMC]) & is.na(postIMCpreIMC_reg[!postIMC_to_preIMC])] <- NA
} else if ("postIMCpreIMC_lm" %in% colnames(to_keep_df)){
  postIMC_to_preIMC <- postIMCpreIMC_lm
} else if ("postIMCpreIMC_reg" %in% colnames(to_keep_df)){
  postIMC_to_preIMC <- postIMCpreIMC_reg
} else{
  postIMC_to_preIMC <- rep(NA, length(df$sample))
}

t1 <- (keep_IMS_to_postIMS & preIMS_to_postIMS & preIMC_to_preIMS & postIMC_to_preIMC)
to_keep_overall <- ifelse(is.na(t1), FALSE, t1) | ifelse(is.na(postIMC_to_postIMS), FALSE, postIMC_to_postIMS)
to_keep_overall[!to_keep_overall][is.na(t1[!to_keep_overall]) | is.na(postIMC_to_postIMS[!to_keep_overall])] <- NA

to_keep_df_aggr <- data.frame(
  sample = df$sample,
  IMS_to_postIMS = keep_IMS_to_postIMS,
  postIMC_to_postIMS = postIMC_to_postIMS,
  preIMS_to_postIMS = preIMS_to_postIMS,
  preIMC_to_preIMS = preIMC_to_preIMS,
  postIMC_to_preIMC = postIMC_to_preIMC,
  overall = to_keep_overall
)
```

## Summarized results

### Continuous
```{r}
# limits
minsc <- c(0, 0)
maxsc <- c(10, 100)

df <- read.csv(input_csv_files[1])
pot_columns1 <- c("sample", "IMS_to_postIMS_quantile50_error", "postIMC_to_preIMC_quantile50_error", "preIMC_to_preIMS_quantile50_error", "preIMS_to_postIMS_quantile50_error", "postIMC_to_postIMS_quantile50_error", "postIMC_to_preIMC_regions_quantile50_error", "postIMC_to_preIMC_regions_quantile50_dice", "preIMC_to_preIMS_regions_quantile50_error", "preIMC_to_preIMS_regions_quantile50_dice", "preIMS_to_postIMS_regions_quantile50_error", "preIMS_to_postIMS_regions_quantile50_dice", "postIMC_to_postIMS_regions_quantile50_error", "postIMC_to_postIMS_regions_quantile50_dice")
pot_columns <- pot_columns1[pot_columns1 %in% colnames(df)]
df1 <- df[, pot_columns, drop = FALSE]

lookupdf <- data.frame(
  metric = c(
    "IMS_to_postIMS_quantile50_error",
    "postIMC_to_preIMC_quantile50_error",
    "preIMC_to_preIMS_quantile50_error",
    "preIMS_to_postIMS_quantile50_error",
    "postIMC_to_postIMS_quantile50_error",
    "postIMC_to_preIMC_regions_quantile50_error",
    "postIMC_to_preIMC_regions_quantile50_dice",
    "preIMC_to_preIMS_regions_quantile50_error",
    "preIMC_to_preIMS_regions_quantile50_dice",
    "preIMS_to_postIMS_regions_quantile50_error",
    "preIMS_to_postIMS_regions_quantile50_dice",
    "postIMC_to_postIMS_regions_quantile50_error",
    "postIMC_to_postIMS_regions_quantile50_dice"
  ),
  confidence = c(
    "IMS_to_postIMS_n_landmarks",
    "postIMC_to_preIMC_n_points_total",
    "preIMC_to_preIMS_n_points_total",
    "preIMS_to_postIMS_n_points_total",
    "postIMC_to_postIMS_n_points_total",
    "postIMC_to_preIMC_regions_n_points_total",
    "postIMC_to_preIMC_regions_n_points_total",
    "preIMC_to_preIMS_regions_n_points_total",
    "preIMC_to_preIMS_regions_n_points_total",
    "preIMS_to_postIMS_regions_n_points_total",
    "preIMS_to_postIMS_regions_n_points_total",
    "postIMC_to_postIMS_regions_n_points_total",
    "postIMC_to_postIMS_regions_n_points_total"
  )
)

pot_columns2 <- c("sample", "IMS_to_postIMS_n_landmarks", "postIMC_to_preIMC_n_points_total", "preIMC_to_preIMS_n_points_total", "preIMS_to_postIMS_n_points_total", "postIMC_to_postIMS_n_points_total", "postIMC_to_preIMC_regions_n_points_total", "preIMC_to_preIMS_regions_n_points_total", "preIMS_to_postIMS_regions_n_points_total", "postIMC_to_postIMS_regions_n_points_total")
pot_columns <- pot_columns2[pot_columns2 %in% colnames(df)]
df2 <- df[, pot_columns, drop = FALSE]

df1_non_empty <- nrow(df1)>0 & ncol(df1)>1
df2_non_empty <- nrow(df2)>0 & ncol(df2)>1
if (df1_non_empty){
  df1l <- tidyr::pivot_longer(df1, -sample, names_to = "metric", values_to = "value")
}
if (df2_non_empty){
  df2l <- tidyr::pivot_longer(df2, -sample, names_to = "confidence", values_to = "confidence_value")
  df2l <- dplyr::left_join(df2l, lookupdf, by = c("confidence"), relationship = "many-to-many")
}
if (df1_non_empty & df2_non_empty){
  dfc <- dplyr::left_join(df1l, df2l, by = c("sample", "metric"))
} else if (df1_non_empty){
  dfc <- df1l
} else if (df2_non_empty){
  dfc <- df2l
} else{
  dfc <- data.frame()
}

dfc$metric_type <- ifelse(stringr::str_detect(dfc$metric, "dice"), "dice", "distance")
dfc$type <- stringr::str_replace(dfc$metric, "(_regions_quantile50_error|_regions_quantile50_dice|_quantile50_error)", "") |>
  stringr::str_replace_all("_", "\n")

dfc$confidence_value_scaled <- dfc$confidence_value
dfc$confidence_value_scaled[dfc$metric_type == "dice"] <- (dfc$confidence_value[dfc$metric_type == "dice"] - minsc[1]) / (maxsc[1] - minsc[1])
dfc$confidence_value_scaled[dfc$metric_type == "dice"][dfc$confidence_value_scaled[dfc$metric_type == "dice"] > 1] <- 1
dfc$confidence_value_scaled[dfc$metric_type == "distance"] <- (dfc$confidence_value[dfc$metric_type == "distance"] - minsc[2]) / (maxsc[2] - minsc[2])
dfc$confidence_value_scaled[dfc$metric_type == "distance"][dfc$confidence_value_scaled[dfc$metric_type == "distance"] > 1] <- 1

dfc$type <- factor(dfc$type, levels = c("IMS\nto\npostIMS", "preIMS\nto\npostIMS", "preIMC\nto\npreIMS", "postIMC\nto\npreIMC", "postIMC\nto\npostIMS"))
dfc$evaluation_type <- ifelse(stringr::str_detect(dfc$metric, "region"), "region", "landmark")
```

The following graph represents a summary of the registration results. On the y-axis are individual samples. On the x-axis different registration metrics are shown. The panels represents the different registration steps. The background color indicates the type of evaluation, either 'landmark' or 'region'. Three different metrics are shown on the x-axis 'landmark_error' (the median distance between matching landmarks), 'regions_dice' (the median dice score between matching regions) and 'regions_error' (the median distance between centroids of matching regions). The size of the points indicates the (somewhat quantitative) confidence in the shown value with bigger sizes meaning more confidence. 
This 'Confidence guess' is determined as follows: for the landmark based metrics ('landmark_error') a value of 0 corresponds to `r minsc[2]` landmarks and a value of 1 correspones to `r maxsc[2]` or more landmarks. 
For the regions based metrics ('regions_dice' and 'regions_error') a value of 0 correspones to `r minsc[1]` regions and a value of 1 correspones to `r maxsc[1]` or more regions. 
The rightmost panel ('postIMC to postIMS') is the direct comparison between postIMC to postIMS and would be the best comparison but it is in general difficult to get good measures between these two images as they are very different. Thus, the other panels show the individual registration steps and if all those panels show good performance the overall registration is probably also good. 
Values that are grayed out are missing. 
Overall some care should be taken when interpreting these results as the presented metrics are not always a good indicator of the quality of the registration. It is therefore advised to also look at the images and plots below, especially for edge cases and cases with missing values.


```{r metrics_summary_plot, warning=FALSE, message=FALSE, fig.width=10,fig.height=5+0.25*length(unique(dfc$sample))}
xlabels <- stringr::str_extract(unique(dfc$metric), "(regions_quantile50_error|regions_quantile50_dice|quantile50_error)") |>
  stringr::str_replace("quantile50_", "") |>
  stringr::str_replace("^error$", "landmark_error")
names(xlabels) <- unique(dfc$metric)

ggplot() +
  geom_tile(data = dfc, aes(metric, sample, fill = evaluation_type)) +
  scale_fill_manual(values = c(region = "gray92", landmark = "white")) +
  new_scale_color() +
  geom_point(
    data = dplyr::filter(dfc, metric_type == "distance"),
    aes(metric, sample, color = value, size = confidence_value_scaled)
  ) +
  scale_color_viridis_c(option = "mako", limits = c(0, 16), na.value = "gray95", direction = -1) +
  new_scale_color() +
  geom_point(
    data = dplyr::filter(dfc, metric_type == "dice"),
    aes(metric, sample, color = value, size = confidence_value_scaled)
  ) +
  scale_color_viridis_c(option = "viridis", limits = c(0, 1), na.value = "gray90") +
  facet_grid(cols = vars(type), scales = "free_x", space = "free_x") +
  scale_x_discrete(labels = xlabels) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(colour = "Dice\ncoefficient", size = "Confidence\nguess", colour_new = "Distance", x = "", y = "", fill = "Evaluation\nType")
```




### Binarized

The following heatmap is a summary of the results. The columns are the different registration steps and the rows are the samples. The color of the cells indicate whether the registration step was successful or not. The used thresholds are: 

| Threshold                                  | Value         |
|:-------------------------------------------|:--------------|
| Minimum completeness IMS ablation marks    | `r min_completenes` |
| Minimum number of landmarks                | `r min_landmarks`    |
| Minimum number of regions                  | `r min_regions`      |
| Maximum error (quantile 50)                | `r min_q50_error`    |
| Minimum Dice coefficient (quantile 50)     | `r min_q50_dice`     |

This evaluation is rather strict meaning that if the 'overall' column is TRUE, the sample is likely to be registered well. However, if the 'overall' column is FALSE or NA, it does not necessarily mean that the sample is not registered well. Therefore it is adviced to check the FALSE and NA entries in the additional plots and images below. 

```{r metrics_summary_plot_bin, fig.width=12, fig.height=3+0.25*length(unique(dfc$sample))}
data_long <- tidyr::pivot_longer(to_keep_df_aggr, c("IMS_to_postIMS", "postIMC_to_postIMS", "preIMS_to_postIMS", "preIMC_to_preIMS", "postIMC_to_preIMC", "overall"))
data_long$name <- factor(data_long$name, c("IMS_to_postIMS", "preIMS_to_postIMS", "preIMC_to_preIMS", "postIMC_to_preIMC", "postIMC_to_postIMS", "overall"))

ggplot2::ggplot(data_long, ggplot2::aes(name, sample, fill = value)) +
  ggplot2::geom_tile() +
  ggplot2::labs(x = NULL, y = NULL, fill = "keep") +
  ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 45, hjust = 1)) +
  ggplot2::scale_fill_manual(values = c("TRUE" = "green", "FALSE" = "red", "NA" = "gray90")) 
```



```{r}
to_include <- "IMS_to_postIMS" %in% snakemake@params[["QC_steps"]] 
```
# IMS to postIMS

## Images

### Ablation marks & registered IMS pixels {.tabset}

The images shown below are the ablation marks (from the postIMS microscopy image) and the IMS pixels (from the IMS image) after registration. 
Color legend for the below images:

| Color | Description  |
|-------|--------------|
| Blue  | Ablation marks |
| Green | IMS pixel    |

```{r, eval=to_include}
tthr <- median(df$IMS_to_postIMS_quantile50_error) + mad(df$IMS_to_postIMS_quantile50_error)
df$IMS_to_postIMS_show_image <- df$IMS_to_postIMS_quantile50_error > tthr

bn <- basename(IMS_to_postIMS_svg)
bn <- stringr::str_replace(bn, "_IMS_to_postIMS_combined_registration_all.svg", "")
project_name <- basename(dirname(dirname(dirname(dirname(IMS_to_postIMS_svg[1])))))
bn <- stringr::str_replace(bn, paste0(project_name, "_"), "")
tdf <- dplyr::right_join(df, data.frame(sample = bn, filename = IMS_to_postIMS_svg), by = "sample")

filenames <- dplyr::filter(tdf, IMS_to_postIMS_show_image)$filename
sample_names_cp <- sample_names
sample_names <- dplyr::filter(tdf, IMS_to_postIMS_show_image)$sample
img_height <- 1000
```
```{r plot_images_IMS_to_postIMS, ref.label='plot_images', results='asis', eval=to_include}
```
```{r, eval=to_include}
sample_names <- sample_names_cp
```
## Distances ablation marks to IMS pixels {.tabset}

The plot below shows the distances (mean, median, etc.) on the x-axis versus the completeness (number of detected ablation marks divided by the total number of IMS pixels) on the y-axis.

```{r, eval=to_include}
vis_type <- "IMS_to_postIMS"
```
```{r pairs_plots_IMS_to_postIMS, ref.label='pairs_plots', results='asis', fig.width=7, fig.height=7, eval=to_include}
```

```{r}
to_include1 <- "postIMC_to_postIMS" %in% snakemake@params[["QC_steps"]] 
```

```{r, results='asis', include=to_include1}
cat("
\n# postIMC to postIMS\n

\n## Summary plots of the registration metrics {.tabset}\n

| Position | Measure | x-axis | y-axis | color  | 
|:---------|:--------|:-------|:-------|:-------|
| Left     | Tissue masks | Distance between centroids | Dice coefficient | |
| Middle   | Landmarks | Summarized distance between landmarks | Number of landmarks | |
| Right    | Regions | Summarized distance between regions | Dice coefficients | Number of regions |
")
```

```{r, include=to_include1}
vis_type <- "postIMC_to_postIMS"
imgtype1 <- stringr::str_split(vis_type, "_to_")[[1]][1]
imgtype2 <- stringr::str_split(vis_type, "_to_")[[1]][2]
```
```{r pairs_plots_postIMC_to_postIMS, ref.label='pairs_plots', results='asis', fig.width=12, fig.height=7, include=to_include1}
```

```{r, results='asis', include=to_include1}
cat("
\n## Summary Table of the registration metrics\n\n
")
print(summary_dt(input_csv_files, vis_type))
```


```{r}
to_include_masks <- ("masks" %in% snakemake@params[["QC_metrics"]]) & to_include1
to_include_landmarks <- ("landmarks" %in% snakemake@params[["QC_metrics"]]) & to_include1
to_include_regions <- ("regions" %in% snakemake@params[["QC_metrics"]]) & to_include1
to_include_images <- ("images" %in% snakemake@params[["QC_metrics"]]) & to_include1
to_include <- to_include_masks | to_include_landmarks | to_include_regions | to_include_images
```


```{r, results='asis', include=to_include}
cat("
\n## Images {.tabset}\n
")
```

```{r, results='asis', include=to_include_masks}
cat(sprintf("
\n### Tissue masks {.tabset}\n

Shown below are the masks of the tissue masks, overlayed on top of each other. Extraction of the tissue masks is not always exact (especially for the postIMS images), so the results might be unreliable.
Color legend for the below images:

| Color | Description |
|-------|-------------|
| Black | Neither     |
| Dark gray  | %s only |
| Light gray  | %s only |
| White | Both        |

", imgtype1, imgtype2))
```

```{r, include=to_include_masks}
filenames <- postIMCmask_to_postIMSmask_png
img_height <- 700
```
```{r plot_images_postIMC_to_postIMS_mask, ref.label='plot_images', results='asis', include=to_include_masks}
```

```{r, results='asis', include=to_include_landmarks}
cat(sprintf("
\n### Images of Landmarks {.tabset}\n

Below are shown the landmarks from the %s image (left) and the %s image (right) after registration. The landmarks are shown as errors where the start of the arrow is on the respective image and the end is the corresponding landmark in the other image. The length of the arrows are therefore the distance between individual landmarks. 

|left | right|
|:----|:-----|
| %s | %s |

", imgtype1, imgtype2, imgtype1, imgtype2))
```

```{r, include=to_include_landmarks}
filenames1 <- landmarks_postIMC_transformed_on_postIMS_png
filenames2 <- landmarks_postIMS_to_postIMC_png
```
```{r plot_2_images_preIMS_to_postIMS_landmarks, ref.label='plot_2_images', results='asis', fig.width=8, fig.height=8, include=to_include_landmarks}
```



```{r, results='asis', include=to_include_regions}
cat(sprintf("
\n### Images of Regions {.tabset}\n

Below are shown the regions from the %s image (left) and the %s image (right) after registration. 

| Color | Description |
|-------|-------------|
| Black | Neither     |
| Dark gray  | %s only |
| Light gray  | %s only |
| White | Both        |

", imgtype1, imgtype2, imgtype1, imgtype2))
```

```{r, include=to_include_regions}
filenames <- regions_postIMC_transformed_on_postIMS_png
img_height <- 700
```
```{r plot_images_postIMC_to_postIMS_regions, ref.label='plot_images', results='asis', include=to_include_regions}
```

```{r, results='asis', include=to_include_images}
cat("
\n### Overlayed {.tabset}\n
")
```

```{r, include=to_include_images}
filenames <- gif_postIMC_postIMS
img_height <- 500
```
```{r plot_images_postIMC_to_postIMS_gif, ref.label='plot_images', results='asis', include=to_include_images}
```


```{r}
to_include1 <- "preIMS_to_postIMS" %in% snakemake@params[["QC_steps"]] 
```


```{r, results='asis', include=to_include1}
cat("
\n# preIMS to postIMS\n

\n## Summary plots of the registration metrics {.tabset}\n

| Position | Measure | x-axis | y-axis | color  | 
|:---------|:--------|:-------|:-------|:-------|
| Left     | Tissue masks | Distance between centroids | Dice coefficient | |
| Middle   | Landmarks | Summarized distance between landmarks | Number of landmarks | |
| Right    | Regions | Summarized distance between regions | Dice coefficients | Number of regions |

")
```

```{r, include=to_include1}
vis_type <- "preIMS_to_postIMS"
imgtype1 <- stringr::str_split(vis_type, "_to_")[[1]][1]
imgtype2 <- stringr::str_split(vis_type, "_to_")[[1]][2]
```
```{r pairs_plots_preIMS_to_postIMS, ref.label='pairs_plots', results='asis', fig.width=15, fig.height=7, include=to_include1}
```

```{r, results='asis', include=to_include1}
cat("
\n## Summary Table of the registration metrics\n
")
```
```{r, include=to_include1}
summary_dt(input_csv_files, vis_type)
```



```{r}
to_include_masks <- ("masks" %in% snakemake@params[["QC_metrics"]]) & to_include1
to_include_landmarks <- ("landmarks" %in% snakemake@params[["QC_metrics"]]) & to_include1
to_include_regions <- ("regions" %in% snakemake@params[["QC_metrics"]]) & to_include1
to_include_images <- ("images" %in% snakemake@params[["QC_metrics"]]) & to_include1
to_include_sitk <- ("sitk" %in% snakemake@params[["QC_metrics"]]) & to_include1
to_include <- to_include_masks | to_include_landmarks | to_include_regions | to_include_images
```

```{r, results='asis', include=to_include}
cat("
\n## Images {.tabset}\n
")
```

```{r, results='asis', include=to_include_masks}
cat(sprintf("
\n### Tissue masks {.tabset}\n

Shown below are the masks of the tissue masks, overlayed on top of each other. Extraction of the tissue masks is not always exact (especially for the postIMS images), so the results might be unreliable.
Color legend for the below images:

| Color | Description |
|-------|-------------|
| Black | Neither     |
| Dark gray  | %s only |
| Light gray  | %s only |
| White | Both        |

", imgtype1, imgtype2))
```

```{r, include=to_include_masks}
filenames <- preIMSmask_to_postIMSmask_png
img_height <- 700
```
```{r plot_images_preIMS_to_postIMS_mask, ref.label='plot_images', results='asis', include=to_include_masks}
```


```{r, results='asis', include=to_include_landmarks}
cat(sprintf("
\n### Images of Landmarks {.tabset}\n

Below are shown the landmarks from the %s image (left) and the %s image (right) after registration. The landmarks are shown as errors where the start of the arrow is on the respective image and the end is the corresponding landmark in the other image. The length of the arrows are therefore the distance between individual landmarks. 

|left | right|
|:----|:-----|
|%s | %s |

", imgtype1, imgtype2, imgtype1, imgtype2))
```

```{r, include=to_include_landmarks}
filenames1 <- landmarks_preIMS_transformed_on_postIMS_png
filenames2 <- landmarks_postIMS_png
```
```{r plot_2_images_preIMS_to_postIMS_landmarks, ref.label='plot_2_images', results='asis', fig.width=8, fig.height=8, include=to_include_landmarks}
```

```{r, results='asis', include=to_include_regions}
cat(sprintf("
\n### Images of Regions {.tabset}\n

Below are shown the regions from the %s image (left) and the %s image (right) after registration. 

| Color | Description |
|-------|-------------|
| Black | Neither     |
| Dark gray  | %s only |
| Light gray  | %s only |
| White | Both        |

", imgtype1, imgtype2, imgtype1, imgtype2))
```

```{r, include=to_include_regions}
filenames <- regions_preIMS_transformed_on_postIMS_png
img_height <- 700
```
```{r plot_images_preIMS_to_postIMS_regions, ref.label='plot_images', results='asis', include=to_include_regions}
```

```{r, results='asis', include=to_include_images}
cat("
\n### Overlayed {.tabset}\n
")
```

```{r, include=to_include_images}
filenames <- gif_preIMS_postIMS
img_height <- 500
```
```{r plot_images_preIMS_to_postIMS_gif, ref.label='plot_images', results='asis', include=to_include_images}
```


```{r, results='asis', include=to_include_sitk}
cat("
\n## Translations based on grid subtracted postIMS to preIMS registration\n

The plot below shows the translations (x and y) based on the grid subtracted postIMS to preIMS registration (using image intensities). The leftmost plot shows the translation in the X direction with the x-axis representing the infered translation from the landmarks and the y-axis the infered translation from the grid subtracted registration. The middle plot shows the same but in the Y direction. The rightmost plot shows the global translation (sqrt(x^2+y^2)) with the x-axis representing the infered translation from the landmarks and the y-axis the infered translation from the grid subtracted registration.

")
```

```{r, fig.width=10, fig.height=5, include=to_include_sitk, eval=to_include_sitk}
fig <- sitk_error_plot(input_csv_files, "preIMS_to_postIMS")
fig
```



```{r}
to_include1 <- "preIMC_to_preIMS" %in% snakemake@params[["QC_steps"]] 
```

```{r, results='asis', include=to_include1}
cat("
\n# preIMC to preIMS\n

\n## Summary plots of the registration metrics {.tabset}\n

| Position | Measure | x-axis | y-axis | color  | 
|:---------|:--------|:-------|:-------|:-------|
| Left     | Tissue masks | Distance between centroids | Dice coefficient | |
| Middle   | Landmarks | Summarized distance between landmarks | Number of landmarks | |
| Right    | Regions | Summarized distance between regions | Dice coefficients | Number of regions |

")
```

```{r, include=to_include1}
vis_type <- "preIMC_to_preIMS"
imgtype1 <- stringr::str_split(vis_type, "_to_")[[1]][1]
imgtype2 <- stringr::str_split(vis_type, "_to_")[[1]][2]
```
```{r pairs_plots_preIMC_to_preIMS, ref.label='pairs_plots', results='asis', fig.width=15, fig.height=7, include=to_include1}
```

```{r, results='asis', include=to_include1}
cat("
\n## Summary Table of the registration metrics\n
")
```
```{r, include=to_include1}
summary_dt(input_csv_files, vis_type)
```



```{r}
to_include_masks <- ("masks" %in% snakemake@params[["QC_metrics"]]) & to_include1
to_include_landmarks <- ("landmarks" %in% snakemake@params[["QC_metrics"]]) & to_include1
to_include_regions <- ("regions" %in% snakemake@params[["QC_metrics"]]) & to_include1
to_include_images <- ("images" %in% snakemake@params[["QC_metrics"]]) & to_include1
to_include <- to_include_masks | to_include_landmarks | to_include_regions | to_include_images
```

```{r, results='asis', include=to_include}
cat("
\n## Images {.tabset}\n
")
```

```{r, results='asis', include=to_include_masks}
cat(sprintf("
\n### Tissue masks {.tabset}\n

Shown below are the masks of the tissue masks, overlayed on top of each other. Extraction of the tissue masks is not always exact (especially for the postIMS images), so the results might be unreliable.
Color legend for the below images:

| Color | Description |
|-------|-------------|
| Black | Neither     |
| Dark gray  | %s only |
| Light gray  | %s only |
| White | Both        |

", imgtype1, imgtype2))
```

```{r, include=to_include_masks}
filenames <- preIMCmask_to_preIMSmask_png
img_height <- 700
```
```{r plot_images_preIMC_to_preIMS_mask, ref.label='plot_images', results='asis', include=to_include_masks}
```

```{r, results='asis', include=to_include_landmarks}
cat(sprintf("
\n### Images of Landmarks {.tabset}\n

Below are shown the landmarks from the %s image (left) and the %s image (right) after registration. The landmarks are shown as errors where the start of the arrow is on the respective image and the end is the corresponding landmark in the other image. The length of the arrows are therefore the distance between individual landmarks. 

|left | right|
|:----|:-----|
|%s | %s |

", imgtype1, imgtype2, imgtype1, imgtype2))
```

```{r, include=to_include_landmarks}
filenames1 <- landmarks_preIMC_transformed_on_preIMS_png
filenames2 <- landmarks_preIMS_png
```
```{r plot_2_images_preIMC_to_preIMS_landmarks, ref.label='plot_2_images', results='asis', fig.width=8, fig.height=8, include=to_include_landmarks}
```

```{r, results='asis', include=to_include_regions}
cat(sprintf("
\n### Images of Regions {.tabset}\n

Below are shown the regions from the %s image (left) and the %s image (right) after registration. 

| Color | Description |
|-------|-------------|
| Black | Neither     |
| Dark gray  | %s only |
| Light gray  | %s only |
| White | Both        |

", imgtype1, imgtype2, imgtype1, imgtype2))
```

```{r, include=to_include_regions}
filenames <- regions_preIMC_transformed_on_preIMS_png
img_height <- 700
```
```{r plot_images_preIMC_to_preIMS_regions, ref.label='plot_images', results='asis', include=to_include_regions}
```

```{r, results='asis', include=to_include_images}
cat("
\n### Overlayed {.tabset}\n
")
```

```{r, include=to_include_images}
filenames <- gif_preIMC_preIMS
img_height <- 500
```
```{r plot_images_preIMC_to_preIMS_gif, ref.label='plot_images', results='asis', include=to_include_images}
```

```{r}
to_include1 <- "postIMC_to_preIMC" %in% snakemake@params[["QC_steps"]] 
```

```{r, results='asis', include=to_include1}
cat("
\n# postIMC to preIMC\n

\n## Summary plots of the registration metrics {.tabset}\n

| Position | Measure | x-axis | y-axis | color  | 
|:---------|:--------|:-------|:-------|:-------|
| Left     | Tissue masks | Distance between centroids | Dice coefficient | |
| Middle   | Landmarks | Summarized distance between landmarks | Number of landmarks | |
| Right    | Regions | Summarized distance between regions | Dice coefficients | Number of regions |

")
```

```{r, include=to_include1}
vis_type <- "postIMC_to_preIMC"
imgtype1 <- stringr::str_split(vis_type, "_to_")[[1]][1]
imgtype2 <- stringr::str_split(vis_type, "_to_")[[1]][2]
```
```{r pairs_plots_postIMC_to_preIMC, ref.label='pairs_plots', results='asis', fig.width=15, fig.height=7, include=to_include1}
```

```{r, results='asis', include=to_include1}
cat("
\n## Summary Table of the registration metrics\n
")
```
```{r, include=to_include1}
summary_dt(input_csv_files, vis_type)
```



```{r}
to_include_masks <- ("masks" %in% snakemake@params[["QC_metrics"]]) & to_include1
to_include_landmarks <- ("landmarks" %in% snakemake@params[["QC_metrics"]]) & to_include1
to_include_regions <- ("regions" %in% snakemake@params[["QC_metrics"]]) & to_include1
to_include_images <- ("images" %in% snakemake@params[["QC_metrics"]]) & to_include1
to_include <- to_include_masks | to_include_landmarks | to_include_regions | to_include_images
```

```{r, results='asis', include=to_include}
cat("
\n## Images {.tabset}\n
")
```

```{r, results='asis', include=to_include_masks}
cat(sprintf("
\n### Tissue masks {.tabset}\n

Shown below are the masks of the tissue masks, overlayed on top of each other. Extraction of the tissue masks is not always exact (especially for the postIMS images), so the results might be unreliable.
Color legend for the below images:

| Color | Description |
|-------|-------------|
| Black | Neither     |
| Dark gray  | %s only |
| Light gray  | %s only |
| White | Both        |

", imgtype1, imgtype2))
```

```{r, include=to_include_masks}
filenames <- postIMCmask_to_preIMCmask_png
img_height <- 700
```
```{r plot_images_postIMC_to_preIMC_mask, ref.label='plot_images', results='asis', include=to_include_masks}
```

```{r, results='asis', include=to_include_landmarks}
cat(sprintf("
\n### Images of Landmarks {.tabset}\n

Below are shown the landmarks from the %s image (left) and the %s image (right) after registration. The landmarks are shown as errors where the start of the arrow is on the respective image and the end is the corresponding landmark in the other image. The length of the arrows are therefore the distance between individual landmarks. 

|left | right|
|:----|:-----|
|%s | %s |

", imgtype1, imgtype2, imgtype1, imgtype2))
```

```{r, include=to_include_landmarks}
filenames1 <- landmarks_postIMC_transformed_on_preIMC_png
filenames2 <- landmarks_preIMC_png
```
```{r plot_2_images_postIMC_to_preIMC_landmarks, ref.label='plot_2_images', results='asis', fig.width=8, fig.height=8, include=to_include_landmarks}
```

```{r, results='asis', include=to_include_regions}
cat(sprintf("
\n### Images of Regions {.tabset}\n

Below are shown the regions from the %s image (left) and the %s image (right) after registration. 

| Color | Description |
|-------|-------------|
| Black | Neither     |
| Dark gray  | %s only |
| Light gray  | %s only |
| White | Both        |

", imgtype1, imgtype2, imgtype1, imgtype2))
```

```{r, include=to_include_regions}
filenames <- regions_postIMC_transformed_on_preIMC_png
img_height <- 700
```
```{r plot_images_postIMC_to_preIMC_regions, ref.label='plot_images', results='asis', include=to_include_regions}
```


```{r, results='asis', include=to_include_images}
cat("
\n### Overlayed {.tabset}\n
")
```

```{r, include=to_include_images}
filenames <- gif_postIMC_preIMC
img_height <- 500
```
```{r plot_images_postIMC_to_preIMC_gif, ref.label='plot_images', results='asis', include=to_include_images}
```



<!-- Source of the zoom box: https://www.w3schools.com/howto/howto_js_image_zoom.asp -->

<style>
* {box-sizing: border-box;}

.img-zoom-container {
  position: relative;
  display: flex;
}

.img-zoom-lens {
  position: absolute;
  border: 1px solid #d4d4d4;
  /*set the size of the lens:*/
  width: 40px;
  height: 40px;
}

.img-zoom-result {
  border: 1px solid #d4d4d4;
  /*set the size of the result div:*/
  width: 500px;
  height: 500px;
}
</style>
<script>
function imageZoom(imgID, resultID) {
  var img, lens, result, cx, cy;
  img = document.getElementById(imgID);
  result = document.getElementById(resultID);
  /*create lens:*/
  lens = document.createElement("DIV");
  lens.setAttribute("class", "img-zoom-lens");
  /*insert lens:*/
  img.parentElement.insertBefore(lens, img);
  /*calculate the ratio between result DIV and lens:*/
  cx = result.offsetWidth / lens.offsetWidth;
  cy = result.offsetHeight / lens.offsetHeight;
  /*set background properties for the result DIV:*/
  result.style.backgroundImage = "url('" + img.src + "')";
  result.style.backgroundSize = (img.width * cx) + "px " + (img.height * cy) + "px";
  /*execute a function when someone moves the cursor over the image, or the lens:*/
  lens.addEventListener("mousemove", moveLens);
  img.addEventListener("mousemove", moveLens);
  /*and also for touch screens:*/
  lens.addEventListener("touchmove", moveLens);
  img.addEventListener("touchmove", moveLens);
  function moveLens(e) {
    var pos, x, y;
    /*prevent any other actions that may occur when moving over the image:*/
    e.preventDefault();
    /*get the cursor's x and y positions:*/
    pos = getCursorPos(e);
    /*calculate the position of the lens:*/
    x = pos.x - (lens.offsetWidth / 2);
    y = pos.y - (lens.offsetHeight / 2);
    /*prevent the lens from being positioned outside the image:*/
    if (x > img.width - lens.offsetWidth) {x = img.width - lens.offsetWidth;}
    if (x < 0) {x = 0;}
    if (y > img.height - lens.offsetHeight) {y = img.height - lens.offsetHeight;}
    if (y < 0) {y = 0;}
    /*set the position of the lens:*/
    lens.style.left = x + "px";
    lens.style.top = y + "px";
    /*display what the lens "sees":*/
    result.style.backgroundPosition = "-" + (x * cx) + "px -" + (y * cy) + "px";
  }
  function getCursorPos(e) {
    var a, x = 0, y = 0;
    e = e || window.event;
    /*get the x and y positions of the image:*/
    a = img.getBoundingClientRect();
    /*calculate the cursor's x and y coordinates, relative to the image:*/
    x = e.pageX - a.left;
    y = e.pageY - a.top;
    /*consider any page scrolling:*/
    x = x - window.pageXOffset;
    y = y - window.pageYOffset;
    return {x : x, y : y};
  }
}
</script>

# IMC to postIMS 

```{r}
to_include1 <- "IMC_to_postIMC" %in% snakemake@params[["QC_steps"]] 
to_include_images <- ("images" %in% snakemake@params[["QC_metrics"]]) & to_include1
```

```{r, results='asis', include=to_include_images}
cat("
\n### Overlayed {.tabset}\n
")
```

```{r, include=to_include_images}
filenames <- plot_IMC_to_preIMC
img_height <- 500
```
```{r plot_images_IMC_to_preIMS, ref.label='plot_images', results='asis', include=to_include_images}
```



### images {.tabset}

```{r}
filenames <- IMC_location_extraction_image
img_height <- 500
sample_names <- sapply(IMC_location_extraction_image, function(x){
  xl <- stringr::str_replace(basename(x),".ome.tiff","")
  xl <- stringr::str_split(xl,"_")[[1]]
  xl[length(xl)]
})
```


```{r plot_images_IMC_location_extraction_image, results='asis', fig.width=8, fig.height=8}
cat("\n\n")
for (i in seq_along(filenames)) {
  filename <- filenames[i]
  if (file.exists(filename)) {
    cat(sprintf("\n\n#### %s\n\n", sample_names[i]))
    cat('<p float="left">')
    cat('<div class="img-zoom-container">')
    cat(sprintf("<img id=\"%s\" src=\"%s\" alt=\"%s\" height=\"%s\"/>", paste0(sample_names[i],"_img"), filename, filename, img_height))
    cat(sprintf("<div id=\"%s\" class=\"img-zoom-result\"></div>", paste0(sample_names[i],"_zoom")))
    cat('</div>')
    cat('</p>')
    cat('<script>')
    cat(sprintf("imageZoom(\"%s\", \"%s\");", paste0(sample_names[i],"_img"), paste0(sample_names[i],"_zoom")))
    cat('</script>')
  }
}
cat("\n\n")
```

